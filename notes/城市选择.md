# 城市选择
- 用到的依赖
```text
npm install better-scroll --save
```

## 路由的使用
```text
- 修改src/router/index.js文件
routes: [
  {
    path: '/',
    name: 'Home',
    component: Home
  },
  {
    path: '/city',
    name: 'City',
    component: City
  }
]

- 使用router-link标签
<router-link to="/city">
但是要注意使用这个标签相当于添加了一个a标签，这样会导致字体变成其他颜色，需要自己添加color:#fff样式

- 使用this.$router.push方法
this.$store.push('/')
```

## 搜索框
- border-size [参考](https://www.cnblogs.com/zhaoran/archive/2013/05/24/3097482.html)

## 城市列表开发
- 改写一像素边框的样式
```html
.border-topbottom
  &:before
    background-color #ccc
  &:after
    background-color #ccc
.border-bottom
  &:before
    background-color #ccc
```

- 搜索框不动，列表动的实现  
限制
```text
通过 overflow:hidden 和 position absolute来进行限制
通过 top 1.58rem漏出搜索框
```
使用Better-scroll [github](https://github.com/ustbhuangyi/better-scroll)
```text
1. 必须符合以下的格式
<div class="wrapper">
  <ul class="content">
    <li>...</li>
    <li>...</li>
    ...
  </ul>
  <!-- you can put some other DOMs here, it won't affect the scrolling -->
</div>
better-scroll会应用在wrapper上，然后wrapper下只有一个元素content，具体看官网

2. js使用
import BScroll from 'better-scroll'
const wrapper = document.querySelector('.wrapper')
const scroll = new BScroll(wrapper)
```
- flex的垂直居中
```text
display flex
flex-direction column
justify-content center
```

## 字母列表的实现
- 兄弟组件通信
```text
技术点:
1. this.$emit()来发射数据
2. 父组件监听转发给另一个组件
```
- 非兄弟组件
```text
通过bus总线来进行数据通信
```
- 列表滑动事件监听
```text
- 绑定事件
@touchstart="handleTouchStart"
@touchmove="handleTouchMove"
@touchend="handleTouchEnd"

- 实现
handleTouchStart() {
  this.moveStatus = true
},
handleTouchMove(e) {
  if (this.moveStatus) {
    const startY = this.$refs['A'][0].offsetTop
    const endY = e.touches[0].clientY - 79
    const index = Math.floor((endY - startY) / 20)
    if (index >= 0 && index < this.letters.length){
      this.$emit('change', this.letters[index])
    }
  }
},
handleTouchEnd() {
  this.moveStatus = false
}
```

## 列表性能优化
- 节流
```text
/*如果在timer还没有执行的时候，又监听到了方法的改动，那就不执行之前的timer了*/
if (this.timer) {
  clearTimeout(this.timer)
}
/*监听到方法之后，16毫秒之后再执行*/
this.timer = setTimeout(() => {
  const endY = e.touches[0].clientY - 79;
  const index = Math.floor((endY - this.startY) / 20)
  if (index >= 0 && index < this.letters.length) {
    this.$emit('change', this.letters[index])
  }
},16)
```

- 不变的数据利用updated()声明周期钩子来优化代码
```text
updated() {
  this.startY = this.$refs['A'][0].offsetTop;
}
```

## 搜索功能
```text
好像没什么特别的
```

## 城市选择（Vuex的使用）
- Vuex  
[官网](https://vuex.vuejs.org/)
![Vuex](https://vuex.vuejs.org/vuex.png)
```text
思路
1. 把数据分派到一个action
this.$store.dispatch('initCity',cityName)

2. 在action中commit数据
actions: {
  initCity(context, city) {
    context.commit('initCity', city);
  }
}

3. 在mutation中mutate数据
mutations: {
  initCity(state, city) {
    state.city = city
  }
}

4. 其实也可以直接调用mutation的方法
this$store.commit('initCity', cityName)
```
